#!/usr/bin/env node
import { existsSync, mkdirSync, writeFileSync } from "fs";
import { dirname, join, resolve } from "path";
import { fileURLToPath } from "url";
import { createRequire } from "module";

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = resolve(__dirname, "..");
const grammarPath = join(repoRoot, "grammar.js");

const require = createRequire(import.meta.url);

function installDslStubs(target) {
  const stub =
    (name) =>
    (...args) => ({ type: name, args });
  target.seq = stub("seq");
  target.choice = stub("choice");
  target.repeat = stub("repeat");
  target.repeat1 = stub("repeat1");
  target.optional = stub("optional");
  target.alias = (value, name) => ({ type: "alias", value, name });
  target.field = (name, value) => ({ type: "field", name, value });
  const token = (arg) => ({ type: "token", arg });
  token.immediate = (arg) => ({ type: "token.immediate", arg });
  target.token = token;
  const prec = (precedence, rule) => ({ type: "prec", precedence, rule });
  prec.left = (precedence, rule) => ({ type: "prec.left", precedence, rule });
  prec.right = (precedence, rule) => ({ type: "prec.right", precedence, rule });
  prec.dynamic = (precedence, rule) => ({
    type: "prec.dynamic",
    precedence,
    rule,
  });
  target.prec = prec;
  target.grammar = (spec) => spec;
}

installDslStubs(global);

if (!existsSync(grammarPath)) {
  throw new Error(`Missing grammar source at ${grammarPath}`);
}

const { indentConstants } = require("../grammar.js");
if (!indentConstants) {
  throw new Error("grammar.js does not export indentConstants");
}

const { BLOCKS = [], COLLECTIONS = [], ALIGNMENTS = [] } = indentConstants;

function uniqueBy(items, keyFn) {
  const seen = new Set();
  return items.filter((item) => {
    const key = keyFn(item);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

function ruleKey(rule) {
  return `${rule.node}|${rule.open}|${rule.close}`;
}

function buildLineBlock(items, capture, formatter) {
  if (items.length === 0) {
    return null;
  }
  const inner = items.map((item) => `  ${formatter(item)}`).join("\n");
  return `[
${inner}
] ${capture}`;
}

function buildIndents() {
  const indentRules = uniqueBy(
    [...BLOCKS, ...COLLECTIONS, ...ALIGNMENTS],
    ruleKey,
  );
  const indentNodes = indentRules.map((rule) => rule.node);
  const outdentTokens = uniqueBy(indentRules, ruleKey).map((rule) => rule.close);
  const alignNodes = uniqueBy(ALIGNMENTS, ruleKey).map((rule) => rule.node);

  const lines = [
    ";; Auto-generated by tenzir/tree-sitter-tql/scripts/generate-indents.mjs. DO NOT EDIT.",
    "",
  ];

  const indentBlock = buildLineBlock(
    uniqueBy(indentNodes, (node) => node),
    "@indent",
    (node) => `(${node})`,
  );
  if (indentBlock) {
    lines.push(indentBlock, "");
  }

  const alignBlock = buildLineBlock(
    uniqueBy(alignNodes, (node) => node),
    "@indent.align",
    (node) => `(${node})`,
  );
  if (alignBlock) {
    lines.push(alignBlock, "");
  }

  const outdentBlock = buildLineBlock(
    uniqueBy(outdentTokens, (token) => token),
    "@outdent",
    (token) => `"${token}"`,
  );
  if (outdentBlock) {
    lines.push(outdentBlock, "");
  }

  // Trim trailing blank line if blocks were appended.
  while (lines.length > 0 && lines[lines.length - 1] === "") {
    lines.pop();
  }
  lines.push("");

  return lines.join("\n");
}

function main() {
  const args = process.argv.slice(2);
  const outputs = args.length > 0
    ? args
    : [
        "languages/tql/indents.scm",
        "queries/tql/indents.scm",
      ];

  const content = buildIndents();

  for (const outputArg of outputs) {
    const outputPath = resolve(repoRoot, outputArg);
    const outputDir = dirname(outputPath);
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }
    writeFileSync(outputPath, content, "utf8");
    console.log(`Wrote ${outputPath}`);
  }
}

main();
