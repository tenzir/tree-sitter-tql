#!/usr/bin/env node
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "fs";
import { dirname, join, resolve } from "path";
import { fileURLToPath } from "url";
import { createRequire } from "module";

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = resolve(__dirname, "..");
const grammarPath = join(repoRoot, "grammar.js");

const require = createRequire(import.meta.url);

function installDslStubs(target) {
  const stub = (name) => (...args) => ({ type: name, args });
  target.seq = stub("seq");
  target.choice = stub("choice");
  target.repeat = stub("repeat");
  target.repeat1 = stub("repeat1");
  target.optional = stub("optional");
  target.alias = (value, name) => ({ type: "alias", value, name });
  target.field = (name, value) => ({ type: "field", name, value });
  const token = (arg) => ({ type: "token", arg });
  token.immediate = (arg) => ({ type: "token.immediate", arg });
  target.token = token;
  const prec = (precedence, rule) => ({ type: "prec", precedence, rule });
  prec.left = (precedence, rule) => ({ type: "prec.left", precedence, rule });
  prec.right = (precedence, rule) => ({ type: "prec.right", precedence, rule });
  prec.dynamic = (precedence, rule) => ({ type: "prec.dynamic", precedence, rule });
  target.prec = prec;
  target.grammar = (spec) => spec;
}

installDslStubs(global);

if (!existsSync(grammarPath)) {
  throw new Error(`Missing grammar source at ${grammarPath}`);
}

const { highlightConstants } = require("../grammar.js");
if (!highlightConstants) {
  throw new Error("grammar.js does not export highlightConstants");
}

const {
  KEYWORDS,
  BUILTIN_VARIABLES,
  BOOLEAN_LITERALS,
  NULL_LITERAL,
  NODE_CAPTURES,
  STRUCTURAL_PATTERNS,
  PUNCTUATION_BRACKETS,
  PUNCTUATION_DELIMITERS,
  OPERATORS,
} = highlightConstants;

function assertGrammarContains(items, type) {
  const source = readFileSync(grammarPath, "utf8");
  for (const item of items) {
    const needle = type === "node" ? `${item}: (` : `"${item}"`;
    if (!source.includes(needle)) {
      throw new Error(`Expected ${type} '${item}' to exist in grammar.js`);
    }
  }
}

function block(values) {
  return `[
${values.map((value) => `  "${value}"`).join("\n")}
]`;
}

function buildHighlights() {
  assertGrammarContains(
    KEYWORDS.concat(BUILTIN_VARIABLES, BOOLEAN_LITERALS, [NULL_LITERAL]),
    "token",
  );
  assertGrammarContains(NODE_CAPTURES.map(({ node }) => node), "node");

  const lines = [
    ";; Auto-generated by tenzir/tree-sitter-tql/scripts/generate-highlights.mjs. DO NOT EDIT.",
    "",
  ];

  lines.push(`${block(KEYWORDS)} @keyword`, "");
  for (const name of BUILTIN_VARIABLES) {
    lines.push(`"${name}" @variable.builtin`, "");
  }
  lines.push(`"${NULL_LITERAL}" @constant.builtin`, "");
  lines.push(`${block(BOOLEAN_LITERALS)} @boolean`, "");

  for (const { node, capture } of NODE_CAPTURES) {
    lines.push(`(${node}) ${capture}`);
  }
  lines.push("");

  for (const pattern of STRUCTURAL_PATTERNS) {
    lines.push(pattern);
  }
  if (STRUCTURAL_PATTERNS.length > 0) {
    lines.push("");
  }

  lines.push(`${block(PUNCTUATION_BRACKETS)} @punctuation.bracket`, "");
  lines.push(`${block(PUNCTUATION_DELIMITERS)} @punctuation.delimiter`, "");
  lines.push(`${block(OPERATORS)} @operator`);

  return `${lines.join("\n")}\n`;
}

function main() {
  const outputArg = process.argv[2] ?? "languages/tql/highlights.scm";
  const outputPath = resolve(process.cwd(), outputArg);
  const outputDir = dirname(outputPath);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  const content = buildHighlights();
  writeFileSync(outputPath, content, "utf8");
  console.log(`Wrote ${outputPath}`);
}

main();
